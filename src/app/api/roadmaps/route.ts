import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { Database } from "@/lib/database.types";
import { roadmapResponseSchema } from "@/lib/roadmapSchema";

export async function POST(request: NextRequest) {
    try {
        const supabase = await createClient<Database>();
        const body = await request.json();

        // Validate structure (excluding DB fields)
        const roadmapData = roadmapResponseSchema.parse(body);

        // 1. Create Roadmap Wrapper
        const { data: roadmap, error: roadmapError } = await supabase
            .from("roadmaps")
            .insert({
                title: `Startup Roadmap: ${new Date().toLocaleDateString()}`,
                idea_description: "Generated by Piely", // We can pass this in body later
            })
            .select()
            .single();

        if (roadmapError) throw roadmapError;

        // 2. Prepare Nodes
        const nodes = [
            ...roadmapData.stages.map((stage) => ({
                id: stage.id,
                roadmap_id: roadmap.id,
                type: "stage",
                title: stage.name,
                description: stage.description,
                order_index: stage.stageOrder,
                metadata: stage, // Store full object for layout/extra props
                status: "pending",
            })),
            ...roadmapData.items.map((item) => ({
                id: item.id,
                roadmap_id: roadmap.id,
                type: "item",
                title: item.title,
                description: item.description,
                status: "pending",
                metadata: item, // Store category, difficulty, etc.
            })),
        ];

        const { error: nodesError } = await supabase
            .from("roadmap_nodes")
            .insert(nodes);

        if (nodesError) throw nodesError;

        // 3. Prepare Edges
        if (roadmapData.edges && roadmapData.edges.length > 0) {
            const edges = roadmapData.edges.map((edge) => ({
                id: edge.id,
                roadmap_id: roadmap.id,
                from_node_id: edge.from,
                to_node_id: edge.to,
                type: edge.type,
            }));

            const { error: edgesError } = await supabase
                .from("roadmap_edges")
                .insert(edges);

            if (edgesError) throw edgesError;
        }

        return NextResponse.json({ success: true, roadmapId: roadmap.id });
    } catch (error) {
        console.error("Save roadmap error:", error);
        return NextResponse.json(
            { error: "Failed to save roadmap" },
            { status: 500 }
        );
    }
}

export async function GET(request: NextRequest) {
    const supabase = await createClient<Database>();
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
        // List all roadmaps
        const { data, error } = await supabase
            .from("roadmaps")
            .select("*")
            .order("created_at", { ascending: false });

        if (error) return NextResponse.json({ error: error.message }, { status: 500 });
        return NextResponse.json(data);
    }

    // Fetch specific roadmap full graph
    const { data: roadmap, error: rError } = await supabase
        .from("roadmaps")
        .select("*")
        .eq("id", id)
        .single();

    if (rError) return NextResponse.json({ error: "Roadmap not found" }, { status: 404 });

    const { data: nodes, error: nError } = await supabase
        .from("roadmap_nodes")
        .select("*")
        .eq("roadmap_id", id);

    const { data: edges, error: eError } = await supabase
        .from("roadmap_edges")
        .select("*")
        .eq("roadmap_id", id);

    if (nError || eError) return NextResponse.json({ error: "Failed to load graph" }, { status: 500 });

    // Reconstruct JSON format for frontend
    const stages = nodes
        .filter((n) => n.type === "stage")
        .sort((a, b) => (a.order_index ?? 0) - (b.order_index ?? 0))
        .map((n) => n.metadata); // The metadata contains the original shape

    const items = nodes
        .filter((n) => n.type === "item")
        .map((n) => ({
            ...(n.metadata as object),
            // Override status if we want to track it
            status: n.status
        }));

    return NextResponse.json({
        id: roadmap.id,
        stages,
        items,
        edges: edges.map(e => ({ id: e.id, from: e.from_node_id, to: e.to_node_id, type: e.type })),
        layoutType: "flow" // default or stored
    });
}
